var bannedProperties = ["Time Remap", "Marker", "Checkbox"];var bannedPropertyNames = {};for (var i = 0; i < bannedProperties.length; ++i) {  bannedPropertyNames[bannedProperties[i]] = true;}var propertyNameMap = {    "Rotation" : "rotation",    "Position" : "translation",    "X Position": "tX",    "Y Position": "tY",    "Scale": "scale",    "Opacity": "alpha",    "Input White": "inWhite",    "Input Black": "inBlack",    "Gamma": "inGamma",    "Output White": "outWhite",    "Output Black": "outBlack"}Array.prototype.equals = function(array) {  if (this.length != array.length)    return false;  for (var i = 0; i < this.length; i++) {    if (this[i] != array[i]) return false;  }  return true;}if (!String.prototype.trim) {  String.prototype.trim = function() {    return this.replace(/^\s+|\s+$/g, '');  };}function getLayerChildren(layer) {  var allLayers = layer.containingComp.layers;  var result = []  for (var i = 1; i <= allLayers.length; ++i) {    var chLayer = allLayers[i];    if (chLayer != null) {      if (chLayer.parent === layer) {        result.push(chLayer);      }    }  }  return result;}// Speed up calls to hasOwnPropertyvar hasOwnProperty = Object.prototype.hasOwnProperty;var logTextField = null;var outputFile = null;function logi() {  for (var i = 0; i < arguments.length; ++i) {    logTextField.text = logTextField.text + arguments[i];  }  logTextField.text = logTextField.text + "\n";}function isEmpty(obj) {  // null and undefined are "empty"  if (obj == null) return true;  // Assume if it has a length property with a non-zero value  // that that property is correct.  if (obj.length > 0) return false;  if (obj.length === 0) return true;  // Otherwise, does it have any properties of its own?  // Note that this doesn't handle  // toString and valueOf enumeration bugs in IE < 9  for (var key in obj) {    if (hasOwnProperty.call(obj, key)) return false;  }  return true;}function getResourceNameFromSourceFile(file) {  var footageToken = "(Footage)/";  var n = file.path.indexOf(footageToken);  var path = "";  if (n != -1) {    path = file.path.substring(n + footageToken.length) + "/";  }  return path + file.name;}function getSequenceFileNamesFromSource(source) {  var path = source.file.path;  var allFilesInDir = new Folder(path).getFiles();  var srcName = source.name;  var pattern = /(.*)\[(\d+)-(\d+)\](.*)/  var matches = srcName.match(pattern)  if (matches === null) return null;  var startIndex = parseInt(matches[2]);  var endIndex = parseInt(matches[3]);  var result = [];  for (var i = 0; i < allFilesInDir.length; ++i) {    var fMatches = allFilesInDir[i].name.match(/([^\d]*)(\d+)(.*)/);    var index = parseInt(fMatches[2]);    if (matches[1] == fMatches[1] && matches[matches.length - 1] == fMatches[fMatches.length - 1] && index >= startIndex && index <= endIndex) {      result.push(getResourceNameFromSourceFile(allFilesInDir[i]));    }  }  return result;}function quaternionWithZRotation(zAngle) {    var rangle = - zAngle * Math.PI / 180 / 2;    var sinAngle = Math.sin(rangle);    var cosAngle = Math.cos(rangle);    return [0, 0, sinAngle, cosAngle];}function serializeLayerComponents(layer) {    if (layer.name == "SPINS") {        var prop = layer.property("Text");        var text = prop.property("Source Text").value;        //var masks = layer.Masks;        //var firstMask = masks.property(1);        //var maskPathProperty = firstMask.property("Mask Path");        //console.log("hi");     }  var result = {};  var source = layer.source;  if (source != null) {    if (source.file != null) {      var sprite = {};      if (source.duration > 0) {        sprite.fileNames = getSequenceFileNamesFromSource(source);      }      else {        sprite.fileNames = [getResourceNameFromSourceFile(source.file)];        sprite.name = getResourceNameFromSourceFile(source.file);      }      var opacity = layer.property("Opacity").valueAtTime(0, false);      if (opacity != 100) sprite.alpha = opacity / 100.0;      result["Sprite"] = sprite;    }    else if (source.name.indexOf("Null") != 0 && source.mainSource && source.mainSource.color !== undefined) { // Solid source      var solid = {};      solid.color = source.mainSource.color;      solid.size = [source.width, source.height];      var opacity = layer.property("Opacity").valueAtTime(0, false);      if (opacity != 100) solid.alpha = opacity / 100.0;      result["Solid"] = solid;    }  }  var levels = layer.Effects.property("Levels (Individual Controls)");  if (levels !== null) {    var lvl = {};    lvl.inWhite = levels.property("Input White").valueAtTime(0, false);    lvl.inBlack = levels.property("Input Black").valueAtTime(0, false);    lvl.inGamma = levels.property("Gamma").valueAtTime(0, false);    lvl.outWhite = levels.property("Output White").valueAtTime(0, false);    lvl.outBlack = levels.property("Output Black").valueAtTime(0, false);    result["ChannelLevels"] = lvl;  }  var text = layer.Text;  if (text !== null && text !== undefined) {    var textDoc = text.property("Source Text").value;    var txt = {};    txt.text = textDoc.text;    txt.fontSize = textDoc.fontSize;    txt.color = textDoc.fillColor;    txt.color.push(layer.property("Opacity").valueAtTime(0, false) / 100);    switch(textDoc.justification) {      case ParagraphJustification.LEFT_JUSTIFY: txt.justification = "left"; break;      case ParagraphJustification.RIGHT_JUSTIFY: txt.justification = "right"; break;      case ParagraphJustification.CENTER_JUSTIFY: txt.justification = "center"; break;    }    result["Text"] = txt;  }  return result;}function shouldSerializeLayer(layer) {  return layer.enabled;}function serializeLayer(layer) {  var result = {};  logi ("LAYER: ", layer.name, ", w: ", layer.width, " h: ", layer.height);  result.name = layer.name;  result.translation = layer.property("Position").valueAtTime(0, false);  var scale = layer.property("Scale").valueAtTime(0, false);  if (!scale.equals([100, 100, 100])) result.scale = scale / 100.0;  var rotation = layer.property("Rotation").valueAtTime(0, false);  if (rotation != 0) result.rotation = quaternionWithZRotation(rotation);  var children = getLayerChildren(layer);  if (children.length > 0) {    var chres = [];    for (var i = 0; i < children.length; ++i) {      if (shouldSerializeLayer(children[i])) {        chres.push(serializeLayer(children[i]));      }    }    chres.reverse();    result.children = chres;  }  if (layer.source != null && layer.source.typeName == "Composition") {    result.compositionRef = layer.source.name;  }  var components = serializeLayerComponents(layer);  if (!isEmpty(components)) result.components = components;  return result;}function parseMarkerComment(comment, result) {  var lines = comment.match(/[^\r\n]+/g);  for (var i = 0; i < lines.length; ++i) {    var kv = lines[i].split(":");    if (kv.length == 2) {      result[kv[0].trim()] = kv[1].trim();    }  }}function getMarkers(layerOrComposition) {  var result = []  if (layerOrComposition.typeName == "Composition") {    var tempLayer = layerOrComposition.layers.addText(layerOrComposition.duration);    var tempText = tempLayer.property("Text").property("Source Text");    tempText.expression = "thisComp.marker.numKeys;";    var numMarkers = parseInt(tempText.value);    for (var i = 1; i <= numMarkers; i++) {      tempText.expression = "thisComp.marker.key(" + i + ").time;";      var markerTime = parseFloat(tempText.value);      tempText.expression = "thisComp.marker.key(" + i + ").comment;";      var markerComment = tempText.value.toString();      result.push({        startTime: markerTime,        comment: markerComment      });    }    tempLayer.remove();  } else {    // Assume layer    var prop = layerOrComposition.property("Marker");    var result = [];    for (var i = 1; i <= prop.numKeys; ++i) {      var marker = {        startTime: prop.keyTime(i),        comment: prop.keyValue(i).comment      }      result.push(marker);    }  }  return result;}function getAnimationMarkers(layerOrComposition) {  var result = getMarkers(layerOrComposition);  for (var i = 0; i < result.length - 1; ++i) {    parseMarkerComment(result[i].comment, result[i]);    result[i].duration = result[i + 1].startTime - result[i].startTime;  }  if (result.length > 0) {    parseMarkerComment(result[result.length - 1].comment, result[result.length -      1]);    result[result.length - 1].duration = layerOrComposition.duration - result[result.length - 1].startTime;  }  return result;}function valueConverterForPropertyName(name) {  switch (name) {    case "Rotation":      return quaternionWithZRotation;    case "Scale":      return function(scale) {        return scale / 100;      }    case "Opacity":      return function(opacity) {        return opacity / 100;      }  }  return function(val) {    return val;  }}function getPropertyAnimation(prop, marker) {  var animationStartTime = marker.startTime;  var animationEndTime = marker.startTime + marker.duration;  //if (prop.numKeys > 0) {  //  animationStartTime = Math.max(animationStartTime, prop.keyTime(1));  //  animationEndTime = Math.min(animationEndTime, prop.keyTime(prop.numKeys));  //}//  if (animationStartTime >= animationEndTime - 0.0001) {//    return null;//  }  var fps = 30.0;  var timeStep = 1.0 / fps;  var sampledPropertyValues = []  var converter = valueConverterForPropertyName(prop.name);  var dEndTime = animationEndTime - 0.0001; // Due to floating point errors, we  // may hit end time, so prevent that.  for (var s = animationStartTime; s < dEndTime; s += timeStep) {    sampledPropertyValues.push(converter(prop.valueAtTime(s, false)));  }  //  logi(JSON.stringify(sampledPropertyValues));  //  sampledPropertyValues.push(converter(prop.valueAtTime(animationEndTime, false)));  result = {//    "startTime": marker.startTime - animationStartTime,    "duration": animationEndTime - animationStartTime,    "values": sampledPropertyValues,  };  if (marker.loops !== undefined) result.numberOfLoops = parseInt(marker.loops);  return result;}function getAnimatableProperties(fromObj, result) {  if (fromObj.numProperties !== undefined) {    for (var i = 1; i <= fromObj.numProperties; ++i) {      getAnimatableProperties(fromObj.property(i), result);    }  }  else if (fromObj.isTimeVarying && bannedPropertyNames[fromObj.name] != true) {    if (!fromObj.isSeparationLeader || !fromObj.dimensionsSeparated) {      result.push(fromObj);    }  }}function mapPropertyName(name) {  if (propertyNameMap[name] !== undefined) return propertyNameMap[name];  return name;}function getLayerAnimationForMarker(layer, marker, result) {  var props = [];  getAnimatableProperties(layer, props);  for (var i = 0; i < props.length; ++i) {    if (props[i] !== null && props[i] !== undefined) {      var anim = getPropertyAnimation(props[i], marker);      if (anim != null) {        var fullyQualifiedPropName = "" + layer.name + "." + mapPropertyName(props[i].name);        logi("PROP: ", fullyQualifiedPropName);        result[fullyQualifiedPropName] = anim;      }    }  }}function getObjectsWithTypeNameFromCollection(collection, typeName) {  var result = [];  for (var i = 0; i < collection.length; ++i) {    if (collection[i].typeName == typeName) {      result.push(collection[i]);    }  }  return result;}function getSelectedCompositions() {  return getObjectsWithTypeNameFromCollection(app.project.selection, "Composition");}function serializeCompositionAnimations(composition) {  var animationMarkers = getAnimationMarkers(composition);  var result = {};  for (var i = 0; i < animationMarkers.length; ++i) {    var animations = {};    logi("Exporting animation: ", animationMarkers[i].animation);    for (var j = 1; j <= composition.layers.length; ++j) {      if (shouldSerializeLayer(composition.layers[j])) {        getLayerAnimationForMarker(composition.layers[j], animationMarkers[i],          animations);      }    }    if (!isEmpty(animations)) {      result[animationMarkers[i].animation] = animations;    }  }  return result;}function serializeComposition(composition) {  var rootLayer = composition.layer("root");  var result;  if (rootLayer != null) {    result = serializeLayer(rootLayer);    result.name = composition.name;    delete result.translation;  } else {    result = {      name: composition.name    };    var children = [];    for (var i = 1; i <= composition.layers.length; ++i) {      var layer = composition.layers[i];      if (layer.parent === null) {        if (shouldSerializeLayer(layer)) {          children.push(serializeLayer(layer));        }      }    }    children.reverse();    if (children.length > 0) result.children = children;  }  var animations = serializeCompositionAnimations(composition);  if (!isEmpty(animations)) {    result.animations = animations;  }  return result;}function exportSelectedCompositions(exportFolderPath) {  var startTime = new Date();  var compositions = getSelectedCompositions();  for (var i = 0; i < compositions.length; ++i) {    var filePath = exportFolderPath + "/" + compositions[i].name + ".json";    logi("Exporting: ", compositions[i].name, " to ", filePath);    var file = new File(filePath);    file.open("w");    try {      file.write(JSON.stringify(serializeComposition(compositions[i]), null, 2));    }    catch (e) {      logi("Exception caught: ", e.toString());    }    file.close();  }  logi("Done. ", new Date().toString());}function buildUI(contextObj) {  var debug = true;  var mainWindow = null;  if (contextObj instanceof Panel) {    mainWindow = contextObj;  } else {    mainWindow = new Window("palette", "Animations", undefined, {      resizeable: true    });    mainWindow.size = [640, 300];  }  //mainWindow.alignment = ['fill', 'fill'];  var topGroup = mainWindow.add("group{orientation:'row'}");  topGroup.alignment = ["fill", "top"];  var setPathButton = topGroup.add("button", undefined, "Browse");  setPathButton.alignment = ["left", "center"];  var filePath = topGroup.add("statictext");  filePath.alignment = ["fill", "fill"];  filePath.text = "Output: (not specified)";  var exportButton = topGroup.add("button", undefined,    "Export selected compositions");  exportButton.alignment = ["right", "center"];  exportButton.enabled = false;  var resultText = mainWindow.add(    "edittext{alignment:['fill','fill'], properties: { multiline:true } }");  logTextField = resultText;  setPathButton.onClick = function(e) {    outputFile = Folder.selectDialog("Choose an output folder");    if (outputFile) {      exportButton.enabled = true;      filePath.text = outputFile.absoluteURI;    } else {      exportButton.enabled = false;    }  };  exportButton.onClick = function(e) {    logTextField.text = "";    exportSelectedCompositions(filePath.text);  };  if (debug) {    filePath.text = "/Users/yglukhov/Projects/falcon/res/compositions";    exportButton.enabled = true;    exportButton.onClick();  }  mainWindow.addEventListener("resize", function(e) {    this.layout.resize();  });  mainWindow.addEventListener("close", function(e) {    app.cancelTask(taskId);    stopServer();  });  mainWindow.onResizing = mainWindow.onResize = function() {    this.layout.resize();  };  if (mainWindow instanceof Window) {    //    mainWindow.onShow = function() {    //        readMetaData();    //    }    mainWindow.show();  } else {    mainWindow.layout.layout(true);    //    readMetaData();  }}buildUI(this);